<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nominal Roll Extractor (Batch Version)</title>
    
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load PyScript -->
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>

    <!-- Custom Styles for Printing and Spinner -->
    <style>
        /* Loading Spinner Animation */
        .loader-spin {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3b82f6; /* Blue */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- PRINT STYLES (FIXED) --- */
        @media print {
            /* Hide the main app container and all other non-report elements */
            #main-app-container, body > py-config, body > py-script, #report-controls {
                display: none !important; /* Be forceful */
            }
            
            /* Show ONLY the report content area and ensure it's visible */
            #report-output-area {
                display: block !important;
                visibility: visible !important;
                position: static; /* Use static positioning for print flow */
                width: 100%;
                overflow-y: visible;
            }

            /* Make sure each page is visible and breaks correctly */
            .print-page {
                display: block !important;
                visibility: visible !important;
                page-break-after: always;
                page-break-inside: avoid;
                width: 100%;
                padding: 1cm;
                box-sizing: border-box;
                box-shadow: none;
                border: none;
                margin: 0;
            }
            
            /* The rest of the styles are for formatting the page */
            h1, h2 {
                text-align: center;
                color: black;
            }
            h1 { font-size: 16pt; font-weight: bold; margin-bottom: 0.5rem; }
            h2 { font-size: 14pt; font-weight: bold; margin-bottom: 1rem; }

            .course-summary {
                font-size: 11pt;
                margin-bottom: 1rem;
                padding: 0.5rem;
                border: 1px solid #ccc;
            }
            
            /* NEW: Footer for Invigilator */
            .invigilator-footer {
                margin-top: 2rem;
                padding-top: 1rem;
                border-top: 1px solid #ccc;
                font-size: 10pt;
            }
            .invigilator-footer div {
                margin-bottom: 0.5rem;
            }
            .invigilator-footer .signature {
                margin-top: 2.5rem;
                border-top: 1px solid black;
                width: 200px;
                padding-top: 4px;
                text-align: center;
            }
            
            /* NEW: Page break helper */
            .print-page-break {
                page-break-after: always;
                border: 0;
                height: 0;
            }

            table {
                width: 100%;
                border-collapse: collapse;
                font-size: 9pt; /* Tighter font */
            }
            th, td {
                border: 1px solid black;
                padding: 2px; /* Tighter padding */
                text-align: left;
                word-wrap: break-word; /* Wrap long text */
            }
            th {
                background-color: #eee;
            }
            
            /* Optimized column widths */
            .sl-col { width: 5%; }
            .course-col { width: 30%; } /* Wider */
            .reg-col { width: 20%; }
            .name-col { width: 35%; }
            .signature-col { width: 10%; } /* Narrower */
        }
        /* --- END PRINT STYLES --- */

        /* --- Report styles for the *viewer* (on-screen) --- */
        .print-page {
            background: white;
            width: 210mm; /* A4 width */
            min-height: 297mm; /* A4 height */
            padding: 2cm;
            margin: 1rem auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            color: black;
            box-sizing: border-box; /* Include padding in width/height */
        }
        .print-page h1 {
            font-size: 16pt;
            font-weight: bold;
            text-align: center;
            margin-bottom: 0.5rem;
        }
        .print-page h2 {
            font-size: 14pt;
            font-weight: bold;
            text-align: center;
            margin-bottom: 1rem;
        }
        .print-page .course-summary {
            font-size: 11pt;
            margin-bottom: 1rem;
            padding: 0.5rem;
            border: 1px solid #ccc;
        }
        .print-page table {
            width: 100%;
            border-collapse: collapse;
            font-size: 9pt; /* Tighter font */
        }
        .print-page th, .print-page td {
            border: 1px solid black;
            padding: 2px; /* Tighter padding */
            text-align: left;
            word-wrap: break-word;
        }
        .print-page th {
            background-color: #eee;
        }
        /* Optimized column widths */
        .print-page .sl-col { width: 5%; }
        .print-page .course-col { width: 30%; } /* Wider */
        .print-page .reg-col { width: 20%; }
        .print-page .name-col { width: 35%; }
        .print-page .signature-col { width: 10%; } /* Narrower */
        
        /* NEW: Footer for Invigilator */
        .invigilator-footer {
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid #ccc;
            font-size: 10pt;
        }
        .invigilator-footer div {
            margin-bottom: 0.5rem;
        }
        .invigilator-footer .signature {
            margin-top: 2.5rem;
            border-top: 1px solid black;
            width: 200px;
            padding-top: 4px;
            text-align: center;
        }

        /* NEW: Page break helper (only visible in print) */
        .print-page-break {
            display: none;
        }
        /* --- END REPORT STYLES --- */

    </style>
</head>
<body class="bg-gray-100 font-sans">
    
    <!-- Define Python Environment -->
    <py-config>
        packages = ["pandas", "pdfplumber==0.7.1"]
    </py-config>

    <!-- Main App Container -->
    <div id="main-app-container" class="container max-w-2xl mx-auto p-4 min-h-screen" style="display: block;">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full">
            
            <header class="mb-6">
                <h1 class="text-3xl font-bold text-gray-800">Nominal Roll Extractor (Batch Version)</h1>
                <p class="text-gray-600 mt-2">
                    Upload multiple Nominal Roll PDFs at once to extract all student data, assign rooms, and print unified reports.
                </p>
            </header>

            <!-- How to Use Instructions -->
            <div class="bg-indigo-50 border border-indigo-200 p-4 rounded-md mb-6">
                <h4 class="font-semibold text-gray-800">How to Use:</h4>
                <ol class="list-decimal list-inside text-sm text-gray-700 mt-2 space-y-1">
                    <li>Click 'Select PDF Files' and choose 1 or 100+ PDF files.</li>
                    <li>Click 'Run Batch Extraction'.</li>
                    <li>Wait for the log to process all files (e.g., "Processing file 1/100...").</li>
                    <li>Click 'Download Combined_Nominal_Roll.csv' for all data.</li>
                    <li>Click 'Generate Room-wise Report' to create seating lists below.</li>
                </ol>
            </div>
            <!-- END HOW TO USE SECTION -->

            <!-- HTML Interface -->
            <div class="space-y-4">
                <div>
                    <label for="pdf-file" class="block text-sm font-medium text-gray-700">1. Select PDF Files:</label>
                    <!-- *** FIX HERE: Entire tag is on one line to prevent parsing errors *** -->
                    <input type="file" id="pdf-file" accept=".pdf" multiple class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"/>
                </div>
                
                <button id="run-button" 
                        py-click="run_extraction" 
                        class="w-full inline-flex justify-center items-center rounded-md border border-transparent bg-indigo-600 py-3 px-4 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50">
                    <!-- Loading spinner (hidden by default) -->
                    <span id="spinner" class="loader-spin -ml-1 mr-3 h-5 w-5 text-white hidden"></span>
                    <span id="button-text">2. Run Batch Extraction</span>
                </button>
            </div>

            <!-- Output & Download Area -->
            <div class="mt-6">
                <h3 class="text-lg font-medium text-gray-900">Processing Log:</h3>
                <div id="status" class="w-full h-48 p-3 mt-2 bg-gray-900 text-gray-200 text-sm font-mono rounded-md overflow-y-auto">
                    Waiting for file...
                </div>
            </div>

            <!-- Hidden data store for JSON -->
            <div id="json-data-store" class="hidden"></div>
            
            <div id="download-area" class="mt-6 space-y-3">
                <!-- 1. Container for the CSV link (so it can be cleared) -->
                <div id="csv-download-container"></div>
                
                <!-- 2. The print button is now separate and won't be cleared -->
                <button id="generate-report-button" class="hidden w-full inline-flex justify-center items-center rounded-md border border-transparent bg-blue-600 py-3 px-4 text-sm font-medium text-white shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50">
                    Generate Room-wise Report
                </button>
            </div>
            
            <!-- 3. NEW: Report controls (Print/Clear) will appear here -->
            <div id="report-controls" class="mt-6 p-4 bg-gray-100 rounded-lg hidden">
                <span id="report-status" class="text-sm font-medium text-gray-700"></span>
                <div class="flex gap-2 mt-2">
                    <button id="final-print-button" class="inline-flex justify-center items-center rounded-md border border-transparent bg-green-600 py-2 px-4 text-sm font-medium text-white shadow-sm hover:bg-green-700">
                        Print Report
                    </button>
                    <button id="clear-report-button" class="inline-flex justify-center items-center rounded-md border border-gray-300 bg-white py-2 px-4 text-sm font-medium text-gray-700 shadow-sm hover:bg-gray-50">
                        Clear Report
                    </button>
                </div>
            </div>
            
        </div>
    </div>

    <!-- 
      *** STRUCTURAL FIX ***
      The Report Output Area is now OUTSIDE the main app container.
      This allows print styles to hide the app and show the report.
    -->
    <div id="report-output-area" class="mt-6 w-full" style="display: none;">
        <!-- Report pages will be injected here -->
    </div>


    <!-- The Python Script (Batch Processing Version) -->
    <py-script>
        import pandas as pd
        import pdfplumber
        import re
        import io
        from js import document, console, URL, Blob, window
        import asyncio
        import json 
        import math 
        from datetime import datetime 
        
        # Get references to our HTML elements
        status_div = document.getElementById("status")
        csv_download_container = document.getElementById("csv-download-container")
        generate_report_button = document.getElementById("generate-report-button")
        json_data_store = document.getElementById("json-data-store")
        report_controls = document.getElementById("report-controls")
        report_output_area = document.getElementById("report-output-area")
        
        run_button = document.getElementById("run-button")
        spinner = document.getElementById("spinner")
        button_text = document.getElementById("button-text")

        def log_message(message):
            """Helper function to print messages to the HTML log."""
            console.log(message)
            status_div.innerHTML += f'<p class="mb-1">&gt; {message}</p>'
            status_div.scrollTop = status_div.scrollHeight

        def show_loader(is_loading):
            """Shows or hides the loader and updates button text."""
            if is_loading:
                run_button.disabled = True
                spinner.classList.remove("hidden")
                button_text.textContent = "Processing..."
            else:
                run_button.disabled = False
                spinner.classList.add("hidden")
                button_text.textContent = "2. Run Batch Extraction"

        def get_sort_key(row):
            """Converts DD.MM.YYYY and HH:MM PM to a sortable format."""
            try:
                date_obj = datetime.strptime(row['Date'], '%d.%m.%Y')
                time_obj = datetime.strptime(row['Time'], '%I:%M %p')
                return (date_obj, time_obj)
            except ValueError as e:
                console.log(f"Sort Error: Could not parse Date '{row['Date']}' or Time '{row['Time']}'. Error: {e}")
                return (datetime.min, datetime.min) 

        async def run_extraction(event=None):
            """
            This function is called when the "Run Extraction" button is clicked.
            """
            try:
                show_loader(True)
                await asyncio.sleep(0)                                
                
                csv_download_container.innerHTML = ""
                generate_report_button.classList.add("hidden")
                json_data_store.innerHTML = ""
                status_div.innerHTML = ""
                report_controls.classList.add("hidden")
                report_output_area.innerHTML = ""
                report_output_area.style.display = 'none'
                
                log_message("Starting batch extraction...")
                
                file_input = document.getElementById("pdf-file")
                file_list = file_input.files
                                
                if file_list.length == 0:
                    log_message("Error: Please select one or more PDF files first.")
                    show_loader(False)
                    return
                
                # --- This is now the master list for ALL files ---
                all_exam_rows = []
                total_files = file_list.length
                log_message(f"Found {total_files} file(s) to process.")
                
                # --- Regex for Register Number (defined once) ---
                reg_num_regex = re.compile(r'([A-Z0-9]{5,}\d{3})')
                
                # --- *** BATCH PROCESSING LOOP *** ---
                for file_index in range(total_files):
                    file = file_list.item(file_index)
                    file_name = file.name
                    log_message(f"--- Processing file {file_index + 1}/{total_files}: {file_name} ---")
                    
                    try:
                        file_bytes = await file.arrayBuffer()
                        pdf_file_obj = io.BytesIO(file_bytes.to_py())
                        
                        # --- Persistent Header Info (resets for each file, but carries over pages) ---
                        course_name = "Unknown"
                        date_val = "Unknown"
                        time_val = "Unknown"
                        
                        with pdfplumber.open(pdf_file_obj) as pdf:
                            total_pages = len(pdf.pages)
                            log_message(f"File has {total_pages} pages.")
                            
                            for i, page in enumerate(pdf.pages):
                                # Log progress periodically
                                if (i + 1) % 10 == 0 or (i + 1) == total_pages:
                                    log_message(f"Processing page {i + 1}/{total_pages}...")
                                    await asyncio.sleep(0) # Yield to browser
                                
                                page_text = page.extract_text(y_tolerance=3, x_tolerance=3)
                                                        
                                course_match = re.search(r'([A-Z0-9]{3,}\d{3,}.*?\[.*?syllabus\])', page_text, re.DOTALL)
                                if course_match:
                                    new_course_name = course_match.group(1).strip().replace('\n', ' ')
                                    new_course_name = new_course_name.replace(' Course [', ' [')
                                    if new_course_name != course_name:
                                        course_name = new_course_name
                                        # log_message(f"Found new Course: {course_name}") # Too noisy for batch

                                # --- *** NEW ROBUST DATE/TIME LOGIC *** ---
                                datetime_match = None
                                # 1. Try to find the specific, known-good string first
                                try:
                                    datetime_match = re.search(
                                        r'Date of Examination.*?(\d{2}\.\d{2}\.\d{4})\s*(\d{1,2}:\d{2}\s*PM|002:0 0PM)', 
                                        page_text, 
                                        re.DOTALL
                                    )
                                except Exception:
                                    pass # Regex might fail on weird text
                                
                                # 2. If it fails, try a more generic (but constrained) fallback
                                if not datetime_match:
                                    try:
                                        # Looks for "Date" ... (0-100 chars) ... "DD.MM.YYYY" ... "HH:MM PM"
                                        datetime_match = re.search(
                                            r'Date[\s\S]{0,100}?(\d{2}\.\d{2}\.\d{4})[\s\S]{0,100}?(\d{1,2}:\d{2}\s*PM|002:0 0PM)', 
                                            page_text, 
                                            re.DOTALL | re.IGNORECASE
                                        )
                                    except Exception:
                                        pass # Fallback also failed
                                # --- *** END ROBUST LOGIC *** ---
                                                        
                                if datetime_match:
                                    new_date_val = datetime_match.group(1).strip()
                                    if new_date_val != date_val:
                                        date_val = new_date_val
                                    
                                    new_time_val = datetime_match.group(2).strip()
                                    if "002:0 0PM" in new_time_val: 